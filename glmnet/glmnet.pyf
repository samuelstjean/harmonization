!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module _glmnet ! in
    interface  ! in :_glmnet

        subroutine get_int_parms(sml,eps,big,mnlam,rsqmax,pmin,exmx) ! in :glmnet5:glmnet5.f
            real*8 :: sml
            real*8 :: eps
            real*8 :: big
            integer :: mnlam
            real*8 :: rsqmax
            real*8 :: pmin
            real*8 :: exmx
        threadsafe
        end subroutine get_int_parms

        subroutine chg_fract_dev(arg) ! in :glmnet5:glmnet5.f
            real*8 :: arg
        threadsafe
        end subroutine chg_fract_dev

        subroutine chg_dev_max(arg) ! in :glmnet5:glmnet5.f
            real*8 :: arg
        threadsafe
        end subroutine chg_dev_max

        subroutine chg_min_flmin(arg) ! in :glmnet5:glmnet5.f
            real*8 :: arg
        threadsafe
        end subroutine chg_min_flmin

        subroutine chg_big(arg) ! in :glmnet5:glmnet5.f
            real*8 :: arg
        threadsafe
        end subroutine chg_big

        subroutine chg_min_lambdas(irg) ! in :glmnet5:glmnet5.f
            integer :: irg
        threadsafe
        end subroutine chg_min_lambdas

        subroutine chg_min_null_prob(arg) ! in :glmnet5:glmnet5.f
            real*8 :: arg
        threadsafe
        end subroutine chg_min_null_prob

        subroutine chg_max_exp(arg) ! in :glmnet5:glmnet5.f
            real*8 :: arg
        threadsafe
        end subroutine chg_max_exp

        subroutine elnet(ka,parm,no,ni,x,y,w,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,intr,maxit,lmu,a0,ca,ia,nin,rsq,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            integer optional :: ka=1 ! Use covariance updates over naive by default
            real*8 :: parm
            integer intent(hide),check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer intent(hide),check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer dimension(*) :: jd
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer optional,depend(x) :: ne=min(shape(x,1), nx)
            integer :: nx
            integer optional,check((flmin < 1.0 || len(ulam)==nlam)),depend(flmin,ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer optional :: isd=1 ! Standardize predictors by default
	    integer optional :: intr=1 ! Include intercept by default
	    integer optional :: maxit=100000 ! Maximum iterations

            ! Outputs
            integer intent(out) :: lmu
            real*8 intent(out),dimension(nlam),depend(nlam) :: a0
            real*8 intent(out),dimension(nx,nlam),depend(nlam) :: ca
            integer intent(out),dimension(nx),depend(nx) :: ia
            integer intent(out),dimension(nlam),depend(nlam) :: nin
            real*8 intent(out),dimension(nlam),depend(nlam) :: rsq
            real*8 intent(out),dimension(nlam),depend(nlam) :: alm
            integer intent(out) :: nlp
            integer intent(out) :: jerr
        threadsafe
        end subroutine elnet

        subroutine elnetu(parm,no,ni,x,y,w,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,intr,maxit,lmu,a0,ca,ia,nin,rsq,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer dimension(*) :: jd
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer :: isd
            integer :: intr
            integer :: maxit
            integer :: lmu
            real*8 dimension(nlam),depend(nlam) :: a0
            real*8 dimension(nx,nlam),depend(nlam) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: nin
            real*8 dimension(nlam),depend(nlam) :: rsq
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine elnetu

        subroutine standard(no,ni,x,y,w,isd,intr,ju,g,xm,xs,ym,ys,xv,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer :: isd
            integer :: intr
            integer dimension(ni),depend(ni) :: ju
            real*8 dimension(ni),depend(ni) :: g
            real*8 dimension(ni),depend(ni) :: xm
            real*8 dimension(ni),depend(ni) :: xs
            real*8 :: ym
            real*8 :: ys
            real*8 dimension(ni),depend(ni) :: xv
            integer :: jerr
        threadsafe
        end subroutine standard

        subroutine elnet1(beta,ni,ju,vp,cl,g,no,ne,nx,x,nlam,flmin,ulam,thr,maxit,xv,lmu,ao,ia,kin,rsqo,almo,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: beta
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            integer dimension(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            real*8 dimension(ni),depend(ni) :: g
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer :: ne
            integer, optional,check(shape(ao,0)==nx),depend(ao) :: nx=shape(ao,0)
            real*8 dimension(no,ni),depend(ni) :: x
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer :: maxit
            real*8 dimension(ni),depend(ni) :: xv
            integer :: lmu
            real*8 dimension(nx,nlam),depend(nlam) :: ao
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: kin
            real*8 dimension(nlam),depend(nlam) :: rsqo
            real*8 dimension(nlam),depend(nlam) :: almo
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine elnet1

        subroutine elnetn(parm,no,ni,x,y,w,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,intr,maxit,lmu,a0,ca,ia,nin,rsq,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer dimension(*) :: jd
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer :: isd
            integer :: intr
            integer :: maxit
            integer :: lmu
            real*8 dimension(nlam),depend(nlam) :: a0
            real*8 dimension(nx,nlam),depend(nlam) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: nin
            real*8 dimension(nlam),depend(nlam) :: rsq
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine elnetn

        subroutine standard1(no,ni,x,y,w,isd,intr,ju,xm,xs,ym,ys,xv,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer :: isd
            integer :: intr
            integer dimension(ni),depend(ni) :: ju
            real*8 dimension(ni),depend(ni) :: xm
            real*8 dimension(ni),depend(ni) :: xs
            real*8 :: ym
            real*8 :: ys
            real*8 dimension(ni),depend(ni) :: xv
            integer :: jerr
        threadsafe
        end subroutine standard1

        subroutine elnet2(beta,ni,ju,vp,cl,y,no,ne,nx,x,nlam,flmin,ulam,thr,maxit,xv,lmu,ao,ia,kin,rsqo,almo,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: beta
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            integer dimension(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            real*8 dimension(no) :: y
            integer, optional,check(len(y)>=no),depend(y) :: no=len(y)
            integer :: ne
            integer, optional,check(shape(ao,0)==nx),depend(ao) :: nx=shape(ao,0)
            real*8 dimension(no,ni),depend(no,ni) :: x
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer :: maxit
            real*8 dimension(ni),depend(ni) :: xv
            integer :: lmu
            real*8 dimension(nx,nlam),depend(nlam) :: ao
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: kin
            real*8 dimension(nlam),depend(nlam) :: rsqo
            real*8 dimension(nlam),depend(nlam) :: almo
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine elnet2

        subroutine chkvars(no,ni,x,ju) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            integer dimension(ni),depend(ni) :: ju
        threadsafe
        end subroutine chkvars

        subroutine uncomp(ni,ca,ia,nin,a) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(a)>=ni),depend(a) :: ni=len(a)
            real*8 dimension(*) :: ca
            integer dimension(*) :: ia
            integer :: nin
            real*8 dimension(ni) :: a
        threadsafe
        end subroutine uncomp

        subroutine modval(a0,ca,ia,nin,n,x,f) ! in :glmnet5:glmnet5.f
            real*8 :: a0
            real*8 dimension(nin) :: ca
            integer dimension(nin),depend(nin) :: ia
            integer, optional,check(len(ca)>=nin),depend(ca) :: nin=len(ca)
            integer, optional,check(shape(x,0)==n),depend(x) :: n=shape(x,0)
            real*8 dimension(n,*) :: x
            real*8 dimension(n),depend(n) :: f
        threadsafe
        end subroutine modval

        subroutine spelnet(ka,parm,no,ni,x,ix,jx,y,w,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,intr,maxit,lmu,a0,ca,ia,nin,rsq,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            integer optional :: ka=1 ! Use covariance updates over naive by default
            real*8 :: parm
            integer :: no
            integer :: ni
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no),depend(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer dimension(*) :: jd
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer optional,depend(x) :: ne=min(ni, nx)
            integer :: nx
            integer optional,check((flmin < 1.0 || len(ulam)==nlam)),depend(flmin,ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer optional :: isd=1 ! Standardize predictors by default
	    integer optional :: intr=1 ! Include intercept by default
	    integer optional :: maxit=100000 ! Maximum iterations

            ! Outputs
            integer intent(out) :: lmu
            real*8 intent(out),dimension(nlam),depend(nlam) :: a0
            real*8 intent(out),dimension(nx,nlam),depend(nlam) :: ca
            integer intent(out),dimension(nx),depend(nx) :: ia
            integer intent(out),dimension(nlam),depend(nlam) :: nin
            real*8 intent(out),dimension(nlam),depend(nlam) :: rsq
            real*8 intent(out),dimension(nlam),depend(nlam) :: alm
            integer intent(out) :: nlp
            integer intent(out) :: jerr
        threadsafe
        end subroutine spelnet

        subroutine spelnetu(parm,no,ni,x,ix,jx,y,w,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,intr,maxit,lmu,a0,ca,ia,nin,rsq,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(len(y)>=no),depend(y) :: no=len(y)
            integer, optional,check(len(vp)>=ni),depend(vp) :: ni=len(vp)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer dimension(*) :: jd
            real*8 dimension(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer :: isd
            integer :: intr
            integer :: maxit
            integer :: lmu
            real*8 dimension(nlam),depend(nlam) :: a0
            real*8 dimension(nx,nlam),depend(nlam) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: nin
            real*8 dimension(nlam),depend(nlam) :: rsq
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine spelnetu

        subroutine spstandard(no,ni,x,ix,jx,y,w,ju,isd,intr,g,xm,xs,ym,ys,xv,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(y)>=no),depend(y) :: no=len(y)
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer dimension(ni) :: ju
            integer :: isd
            integer :: intr
            real*8 dimension(ni),depend(ni) :: g
            real*8 dimension(ni),depend(ni) :: xm
            real*8 dimension(ni),depend(ni) :: xs
            real*8 :: ym
            real*8 :: ys
            real*8 dimension(ni),depend(ni) :: xv
            integer :: jerr
        threadsafe
        end subroutine spstandard

        subroutine spelnet1(beta,ni,g,no,w,ne,nx,x,ix,jx,ju,vp,cl,nlam,flmin,ulam,thr,maxit,xm,xs,xv,lmu,ao,ia,kin,rsqo,almo,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: beta
            integer, optional,check(len(g)>=ni),depend(g) :: ni=len(g)
            real*8 dimension(ni) :: g
            integer, optional,check(len(w)>=no),depend(w) :: no=len(w)
            real*8 dimension(no) :: w
            integer :: ne
            integer, optional,check(shape(ao,0)==nx),depend(ao) :: nx=shape(ao,0)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            integer dimension(ni),depend(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer :: maxit
            real*8 dimension(ni),depend(ni) :: xm
            real*8 dimension(ni),depend(ni) :: xs
            real*8 dimension(ni),depend(ni) :: xv
            integer :: lmu
            real*8 dimension(nx,nlam),depend(nlam) :: ao
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: kin
            real*8 dimension(nlam),depend(nlam) :: rsqo
            real*8 dimension(nlam),depend(nlam) :: almo
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine spelnet1

        subroutine spelnetn(parm,no,ni,x,ix,jx,y,w,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,intr,maxit,lmu,a0,ca,ia,nin,rsq,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(len(y)>=no),depend(y) :: no=len(y)
            integer, optional,check(len(vp)>=ni),depend(vp) :: ni=len(vp)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer dimension(*) :: jd
            real*8 dimension(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer :: isd
            integer :: intr
            integer :: maxit
            integer :: lmu
            real*8 dimension(nlam),depend(nlam) :: a0
            real*8 dimension(nx,nlam),depend(nlam) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: nin
            real*8 dimension(nlam),depend(nlam) :: rsq
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine spelnetn

        subroutine spstandard1(no,ni,x,ix,jx,y,w,ju,isd,intr,xm,xs,ym,ys,xv,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(y)>=no),depend(y) :: no=len(y)
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer dimension(ni) :: ju
            integer :: isd
            integer :: intr
            real*8 dimension(ni),depend(ni) :: xm
            real*8 dimension(ni),depend(ni) :: xs
            real*8 :: ym
            real*8 :: ys
            real*8 dimension(ni),depend(ni) :: xv
            integer :: jerr
        threadsafe
        end subroutine spstandard1

        subroutine spelnet2(beta,ni,y,w,no,ne,nx,x,ix,jx,ju,vp,cl,nlam,flmin,ulam,thr,maxit,xm,xs,xv,lmu,ao,ia,kin,rsqo,almo,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: beta
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            real*8 dimension(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer, optional,check(len(y)>=no),depend(y) :: no=len(y)
            integer :: ne
            integer, optional,check(shape(ao,0)==nx),depend(ao) :: nx=shape(ao,0)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            integer dimension(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer :: maxit
            real*8 dimension(ni),depend(ni) :: xm
            real*8 dimension(ni),depend(ni) :: xs
            real*8 dimension(ni),depend(ni) :: xv
            integer :: lmu
            real*8 dimension(nx,nlam),depend(nlam) :: ao
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: kin
            real*8 dimension(nlam),depend(nlam) :: rsqo
            real*8 dimension(nlam),depend(nlam) :: almo
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine spelnet2

        subroutine spchkvars(no,ni,x,ix,ju) ! in :glmnet5:glmnet5.f
            integer :: no
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(ni) :: ju
        threadsafe
        end subroutine spchkvars

        subroutine cmodval(a0,ca,ia,nin,x,ix,jx,n,f) ! in :glmnet5:glmnet5.f
            real*8 :: a0
            real*8 dimension(*) :: ca
            integer dimension(*) :: ia
            integer :: nin
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            integer, optional,check(len(f)>=n),depend(f) :: n=len(f)
            real*8 dimension(n) :: f
        threadsafe
        end subroutine cmodval

        function row_prod(i,j,ia,ja,ra,w) ! in :glmnet5:glmnet5.f
            integer :: i
            integer :: j
            integer dimension(*) :: ia
            integer dimension(*) :: ja
            real*8 dimension(*) :: ra
            real*8 dimension(*) :: w
            real*8 :: row_prod
        end function row_prod

        function dot(x,y,mx,my,nx,ny,w) ! in :glmnet5:glmnet5.f
            real*8 dimension(*) :: x
            real*8 dimension(*) :: y
            integer dimension(*) :: mx
            integer dimension(*) :: my
            integer :: nx
            integer :: ny
            real*8 dimension(*) :: w
            real*8 :: dot
        end function dot

        subroutine lognet(parm,no,ni,nc,x,y,g,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,intr,maxit,kopt,lmu,a0,ca,ia,nin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer intent(hide),check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer intent(hide),check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            integer check(shape(y,1)==max(2,nc)),depend(y) :: nc
	    real*8 dimension(no,ni) :: x
            real*8 dimension(no,max(2,nc)),depend(no) :: y
            real*8 dimension(no,shape(y,1)),depend(no) :: g
            integer dimension(*) :: jd
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer optional,depend(x) :: ne=min(shape(x,1), nx)
            integer :: nx
            integer optional,check((flmin < 1.0 || len(ulam)<=nlam)),depend(flmin,ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer optional :: isd=1 ! Standardize predictors by default
            integer optional :: intr=1 ! Include intercept by default
            integer optional :: maxit=100000
            integer optional :: kopt=0 ! Use Newton's by default

	    ! Outputs
            integer intent(out) :: lmu
            real*8 intent(out),dimension(nc,nlam),depend(nlam,nc) :: a0
            real*8 intent(out),dimension(nx,nc,nlam),depend(nlam,nc) :: ca
            integer intent(out),dimension(nx),depend(nx) :: ia
            integer intent(out),dimension(nlam),depend(nlam) :: nin
            real*8 intent(out),dimension(nlam),depend(nlam) :: dev0
            real*8 intent(out),dimension(nlam),depend(nlam) :: dev
            real*8 intent(out),dimension(nlam),depend(nlam) :: alm
            integer intent(out) :: nlp
            integer intent(out) :: jerr
        threadsafe
        end subroutine lognet

        subroutine lstandard1(no,ni,x,w,ju,isd,intr,xm,xs) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: w
            integer dimension(ni),depend(ni) :: ju
            integer :: isd
            integer :: intr
            real*8 dimension(ni),depend(ni) :: xm
            real*8 dimension(ni),depend(ni) :: xs
        threadsafe
        end subroutine lstandard1
        subroutine multlstandard1(no,ni,x,w,ju,isd,intr,xm,xs,xv) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: w
            integer dimension(ni),depend(ni) :: ju
            integer :: isd
            integer :: intr
            real*8 dimension(ni),depend(ni) :: xm
            real*8 dimension(ni),depend(ni) :: xs
            real*8 dimension(ni),depend(ni) :: xv
        threadsafe
        end subroutine multlstandard1
        subroutine lognet2n(parm,no,ni,x,y,g,w,ju,vp,cl,ne,nx,nlam,flmin,ulam,shri,isd,intr,maxit,kopt,lmu,a0,a,m,kin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: y
            real*8 dimension(no),depend(no) :: g
            real*8 dimension(no),depend(no) :: w
            integer dimension(ni),depend(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(a,0)==nx),depend(a) :: nx=shape(a,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: shri
            integer :: isd
            integer :: intr
            integer :: maxit
            integer :: kopt
            integer :: lmu
            real*8 dimension(nlam),depend(nlam) :: a0
            real*8 dimension(nx,nlam),depend(nlam) :: a
            integer dimension(nx),depend(nx) :: m
            integer dimension(nlam),depend(nlam) :: kin
            real*8 :: dev0
            real*8 dimension(nlam),depend(nlam) :: dev
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine lognet2n
        function dev2(n,w,y,p,pmin) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(w)>=n),depend(w) :: n=len(w)
            real*8 dimension(n) :: w
            real*8 dimension(n),depend(n) :: y
            real*8 dimension(n),depend(n) :: p
            real*8 :: pmin
            real*8 :: dev2
        end function dev2
        function azero(n,y,g,q,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(y)>=n),depend(y) :: n=len(y)
            real*8 dimension(n) :: y
            real*8 dimension(n),depend(n) :: g
            real*8 dimension(n),depend(n) :: q
            integer :: jerr
            real*8 :: azero
        end function azero
        subroutine lognetn(parm,no,ni,nc,x,y,g,w,ju,vp,cl,ne,nx,nlam,flmin,ulam,shri,isd,intr,maxit,kopt,lmu,a0,a,m,kin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            integer, optional,check(shape(y,1)==nc),depend(y) :: nc=shape(y,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no,nc),depend(no) :: y
            real*8 dimension(no,nc),depend(no,nc) :: g
            real*8 dimension(no),depend(no) :: w
            integer dimension(ni),depend(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(a,0)==nx),depend(a) :: nx=shape(a,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: shri
            integer :: isd
            integer :: intr
            integer :: maxit
            integer :: kopt
            integer :: lmu
            real*8 dimension(nc,nlam),depend(nc,nlam) :: a0
            real*8 dimension(nx,nc,nlam),depend(nc,nlam) :: a
            integer dimension(nx),depend(nx) :: m
            integer dimension(nlam),depend(nlam) :: kin
            real*8 :: dev0
            real*8 dimension(nlam),depend(nlam) :: dev
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine lognetn
        subroutine kazero(kk,n,y,g,q,az,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(y,1)==kk),depend(y) :: kk=shape(y,1)
            integer, optional,check(shape(y,0)==n),depend(y) :: n=shape(y,0)
            real*8 dimension(n,kk) :: y
            real*8 dimension(n,kk),depend(n,kk) :: g
            real*8 dimension(n),depend(n) :: q
            real*8 dimension(kk),depend(kk) :: az
            integer :: jerr
        threadsafe
        end subroutine kazero
        function elc(parm,n,cl,a,m) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(len(a)>=n),depend(a) :: n=len(a)
            real*8 dimension(2) :: cl
            real*8 dimension(n) :: a
            integer dimension(n),depend(n) :: m
            real*8 :: elc
        end function elc
        function nintot(ni,nx,nc,a,m,nin,is) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(is)>=ni),depend(is) :: ni=len(is)
            integer, optional,check(shape(a,0)==nx),depend(a) :: nx=shape(a,0)
            integer, optional,check(shape(a,1)==nc),depend(a) :: nc=shape(a,1)
            real*8 dimension(nx,nc) :: a
            integer dimension(nx),depend(nx) :: m
            integer :: nin
            integer dimension(ni) :: is
            integer :: nintot
        end function nintot
        subroutine luncomp(ni,nx,nc,ca,ia,nin,a) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(a,0)==ni),depend(a) :: ni=shape(a,0)
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(shape(ca,1)==nc),depend(ca) :: nc=shape(ca,1)
            real*8 dimension(nx,nc) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer :: nin
            real*8 dimension(ni,nc),depend(nc) :: a
        threadsafe
        end subroutine luncomp
        subroutine lmodval(nt,x,nc,nx,a0,ca,ia,nin,ans) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(x,0)==nt),depend(x) :: nt=shape(x,0)
            real*8 dimension(nt,*) :: x
            integer, optional,check(len(a0)>=nc),depend(a0) :: nc=len(a0)
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            real*8 dimension(nc) :: a0
            real*8 dimension(nx,nc),depend(nc) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer :: nin
            real*8 dimension(nc,nt),depend(nc,nt) :: ans
        threadsafe
        end subroutine lmodval

        subroutine splognet(parm,no,ni,nc,x,ix,jx,y,g,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,intr,maxit,kopt,lmu,a0,ca,ia,nin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer :: no
            integer :: ni
            integer :: nc
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no,max(2,nc)),depend(no,nc) :: y
            real*8 dimension(no,shape(y,1)),depend(no,y) :: g
            integer dimension(*) :: jd
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer optional,depend(ni,nx) :: ne=min(ni,nx)
            integer :: nx
            integer optional,check((flmin < 1.0 || len(ulam)<=nlam)),depend(flmin,ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer optional :: isd=1 ! Standardize predictors by default
            integer optional :: intr=1 ! Include intercept by default
            integer optional :: maxit=100000
            integer optional :: kopt=0 ! Use Newton's by default

	    ! Outputs
            integer intent(out) :: lmu
            real*8 intent(out),dimension(nc,nlam),depend(nlam,nc) :: a0
            real*8 intent(out),dimension(nx,nc,nlam),depend(nx,nc,nlam) :: ca
            integer intent(out),dimension(nx),depend(nx) :: ia
            integer intent(out),dimension(nlam),depend(nlam) :: nin
            real*8 intent(out),dimension(nlam),depend(nlam) :: dev0
            real*8 intent(out),dimension(nlam),depend(nlam) :: dev
            real*8 intent(out),dimension(nlam),depend(nlam) :: alm
            integer intent(out) :: nlp
            integer intent(out) :: jerr
        threadsafe
        end subroutine splognet

        subroutine multsplstandard2(no,ni,x,ix,jx,w,ju,isd,intr,xm,xs,xv) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(w)>=no),depend(w) :: no=len(w)
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no) :: w
            integer dimension(ni) :: ju
            integer :: isd
            integer :: intr
            real*8 dimension(ni),depend(ni) :: xm
            real*8 dimension(ni),depend(ni) :: xs
            real*8 dimension(ni),depend(ni) :: xv
        threadsafe
        end subroutine multsplstandard2
        subroutine splstandard2(no,ni,x,ix,jx,w,ju,isd,intr,xm,xs) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(w)>=no),depend(w) :: no=len(w)
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no) :: w
            integer dimension(ni) :: ju
            integer :: isd
            integer :: intr
            real*8 dimension(ni),depend(ni) :: xm
            real*8 dimension(ni),depend(ni) :: xs
        threadsafe
        end subroutine splstandard2
        subroutine sprlognet2n(parm,no,ni,x,ix,jx,y,g,w,ju,vp,cl,ne,nx,nlam,flmin,ulam,shri,isd,intr,maxit,kopt,xb,xs,lmu,a0,a,m,kin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(len(y)>=no),depend(y) :: no=len(y)
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no) :: y
            real*8 dimension(no),depend(no) :: g
            real*8 dimension(no),depend(no) :: w
            integer dimension(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(a,0)==nx),depend(a) :: nx=shape(a,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: shri
            integer :: isd
            integer :: intr
            integer :: maxit
            integer :: kopt
            real*8 dimension(ni),depend(ni) :: xb
            real*8 dimension(ni),depend(ni) :: xs
            integer :: lmu
            real*8 dimension(nlam),depend(nlam) :: a0
            real*8 dimension(nx,nlam),depend(nlam) :: a
            integer dimension(nx),depend(nx) :: m
            integer dimension(nlam),depend(nlam) :: kin
            real*8 :: dev0
            real*8 dimension(nlam),depend(nlam) :: dev
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine sprlognet2n
        subroutine sprlognetn(parm,no,ni,nc,x,ix,jx,y,g,w,ju,vp,cl,ne,nx,nlam,flmin,ulam,shri,isd,intr,maxit,kopt,xb,xs,lmu,a0,a,m,kin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(y,0)==no),depend(y) :: no=shape(y,0)
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            integer, optional,check(shape(y,1)==nc),depend(y) :: nc=shape(y,1)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no,nc) :: y
            real*8 dimension(no,nc),depend(no,nc) :: g
            real*8 dimension(no),depend(no) :: w
            integer dimension(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(a,0)==nx),depend(a) :: nx=shape(a,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: shri
            integer :: isd
            integer :: intr
            integer :: maxit
            integer :: kopt
            real*8 dimension(ni),depend(ni) :: xb
            real*8 dimension(ni),depend(ni) :: xs
            integer :: lmu
            real*8 dimension(nc,nlam),depend(nc,nlam) :: a0
            real*8 dimension(nx,nc,nlam),depend(nc,nlam) :: a
            integer dimension(nx),depend(nx) :: m
            integer dimension(nlam),depend(nlam) :: kin
            real*8 :: dev0
            real*8 dimension(nlam),depend(nlam) :: dev
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine sprlognetn
        subroutine lcmodval(nc,nx,a0,ca,ia,nin,x,ix,jx,n,f) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(a0)>=nc),depend(a0) :: nc=len(a0)
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            real*8 dimension(nc) :: a0
            real*8 dimension(nx,nc),depend(nc) :: ca
            integer dimension(*) :: ia
            integer :: nin
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            integer, optional,check(shape(f,1)==n),depend(f) :: n=shape(f,1)
            real*8 dimension(nc,n),depend(nc) :: f
        threadsafe
        end subroutine lcmodval
        subroutine coxnet(parm,no,ni,x,y,d,g,w,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,maxit,isd,lmu,ca,ia,nin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: y
            real*8 dimension(no),depend(no) :: d
            real*8 dimension(no),depend(no) :: g
            real*8 dimension(no),depend(no) :: w
            integer dimension(*) :: jd
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer :: maxit
            integer :: isd
            integer :: lmu
            real*8 dimension(nx,nlam),depend(nlam) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: nin
            real*8 :: dev0
            real*8 dimension(nlam),depend(nlam) :: dev
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine coxnet
        subroutine cstandard(no,ni,x,w,ju,isd,xs) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: w
            integer dimension(ni),depend(ni) :: ju
            integer :: isd
            real*8 dimension(ni),depend(ni) :: xs
        threadsafe
        end subroutine cstandard
        subroutine coxnet1(parm,no,ni,x,y,d,g,q,ju,vp,cl,ne,nx,nlam,flmin,ulam,cthri,isd,maxit,lmu,ao,m,kin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: y
            real*8 dimension(no),depend(no) :: d
            real*8 dimension(no),depend(no) :: g
            real*8 dimension(no),depend(no) :: q
            integer dimension(ni),depend(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(ao,0)==nx),depend(ao) :: nx=shape(ao,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: cthri
            integer :: isd
            integer :: maxit
            integer :: lmu
            real*8 dimension(nx,nlam),depend(nlam) :: ao
            integer dimension(nx),depend(nx) :: m
            integer dimension(nlam),depend(nlam) :: kin
            real*8 :: dev0
            real*8 dimension(nlam),depend(nlam) :: dev
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine coxnet1
        subroutine cxmodval(ca,ia,nin,n,x,f) ! in :glmnet5:glmnet5.f
            real*8 dimension(nin) :: ca
            integer dimension(nin),depend(nin) :: ia
            integer, optional,check(len(ca)>=nin),depend(ca) :: nin=len(ca)
            integer, optional,check(shape(x,0)==n),depend(x) :: n=shape(x,0)
            real*8 dimension(n,*) :: x
            real*8 dimension(n),depend(n) :: f
        threadsafe
        end subroutine cxmodval
        subroutine groups(no,y,d,q,nk,kp,jp,t0,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(y)>=no),depend(y) :: no=len(y)
            real*8 dimension(no) :: y
            real*8 dimension(no),depend(no) :: d
            real*8 dimension(no),depend(no) :: q
            integer :: nk
            integer dimension(*) :: kp
            integer dimension(no),depend(no) :: jp
            real*8 :: t0
            integer :: jerr
        threadsafe
        end subroutine groups
        subroutine outer(no,nk,d,dk,kp,jp,e,wr,w,jerr,u) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(d)>=no),depend(d) :: no=len(d)
            integer, optional,check(len(dk)>=nk),depend(dk) :: nk=len(dk)
            real*8 dimension(no) :: d
            real*8 dimension(nk) :: dk
            integer dimension(nk),depend(nk) :: kp
            integer dimension(no),depend(no) :: jp
            real*8 dimension(no),depend(no) :: e
            real*8 dimension(no),depend(no) :: wr
            real*8 dimension(no),depend(no) :: w
            integer :: jerr
            real*8 dimension(no),depend(no) :: u
        threadsafe
        end subroutine outer
        subroutine vars(no,ni,x,w,ixx,v) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: w
            integer dimension(ni),depend(ni) :: ixx
            real*8 dimension(ni),depend(ni) :: v
        threadsafe
        end subroutine vars
        subroutine died(no,nk,d,kp,jp,dk) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(d)>=no),depend(d) :: no=len(d)
            integer, optional,check(len(kp)>=nk),depend(kp) :: nk=len(kp)
            real*8 dimension(no) :: d
            integer dimension(nk) :: kp
            integer dimension(no),depend(no) :: jp
            real*8 dimension(nk),depend(nk) :: dk
        threadsafe
        end subroutine died
        subroutine usk(no,nk,kp,jp,e,u) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(jp)>=no),depend(jp) :: no=len(jp)
            integer, optional,check(len(kp)>=nk),depend(kp) :: nk=len(kp)
            integer dimension(nk) :: kp
            integer dimension(no) :: jp
            real*8 dimension(no),depend(no) :: e
            real*8 dimension(nk),depend(nk) :: u
        threadsafe
        end subroutine usk
        function risk(no,ni,nk,d,dk,f,e,kp,jp,u) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(d)>=no),depend(d) :: no=len(d)
            integer :: ni
            integer, optional,check(len(dk)>=nk),depend(dk) :: nk=len(dk)
            real*8 dimension(no) :: d
            real*8 dimension(nk) :: dk
            real*8 dimension(no),depend(no) :: f
            real*8 dimension(no),depend(no) :: e
            integer dimension(nk),depend(nk) :: kp
            integer dimension(no),depend(no) :: jp
            real*8 dimension(nk),depend(nk) :: u
            real*8 :: risk
        end function risk
        subroutine loglike(no,ni,x,y,d,g,w,nlam,a,flog,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: y
            real*8 dimension(no),depend(no) :: d
            real*8 dimension(no),depend(no) :: g
            real*8 dimension(no),depend(no) :: w
            integer, optional,check(shape(a,1)==nlam),depend(a) :: nlam=shape(a,1)
            real*8 dimension(ni,nlam),depend(ni) :: a
            real*8 dimension(nlam),depend(nlam) :: flog
            integer :: jerr
        threadsafe
        end subroutine loglike
        subroutine fishnet(parm,no,ni,x,y,g,w,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,intr,maxit,lmu,a0,ca,ia,nin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: y
            real*8 dimension(no),depend(no) :: g
            real*8 dimension(no),depend(no) :: w
            integer dimension(*) :: jd
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer :: isd
            integer :: intr
            integer :: maxit
            integer :: lmu
            real*8 dimension(nlam),depend(nlam) :: a0
            real*8 dimension(nx,nlam),depend(nlam) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: nin
            real*8 :: dev0
            real*8 dimension(nlam),depend(nlam) :: dev
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine fishnet
        subroutine fishnet1(parm,no,ni,x,y,g,q,ju,vp,cl,ne,nx,nlam,flmin,ulam,shri,isd,intr,maxit,lmu,a0,ca,m,kin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: y
            real*8 dimension(no),depend(no) :: g
            real*8 dimension(no),depend(no) :: q
            integer dimension(ni),depend(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: shri
            integer :: isd
            integer :: intr
            integer :: maxit
            integer :: lmu
            real*8 dimension(nlam),depend(nlam) :: a0
            real*8 dimension(nx,nlam),depend(nlam) :: ca
            integer dimension(nx),depend(nx) :: m
            integer dimension(nlam),depend(nlam) :: kin
            real*8 :: dev0
            real*8 dimension(nlam),depend(nlam) :: dev
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine fishnet1
        function nonzero(n,v) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(v)>=n),depend(v) :: n=len(v)
            real*8 dimension(n) :: v
            integer :: nonzero
        end function nonzero
        subroutine solns(ni,nx,lmu,a,ia,nin,b) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(b,0)==ni),depend(b) :: ni=shape(b,0)
            integer, optional,check(shape(a,0)==nx),depend(a) :: nx=shape(a,0)
            integer, optional,check(shape(a,1)==lmu),depend(a) :: lmu=shape(a,1)
            real*8 dimension(nx,lmu) :: a
            integer dimension(nx),depend(nx) :: ia
            integer dimension(lmu),depend(lmu) :: nin
            real*8 dimension(ni,lmu),depend(lmu) :: b
        threadsafe
        end subroutine solns
        subroutine lsolns(ni,nx,nc,lmu,a,ia,nin,b) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(b,0)==ni),depend(b) :: ni=shape(b,0)
            integer, optional,check(shape(a,0)==nx),depend(a) :: nx=shape(a,0)
            integer, optional,check(shape(a,1)==nc),depend(a) :: nc=shape(a,1)
            integer, optional,check(shape(a,2)==lmu),depend(a) :: lmu=shape(a,2)
            real*8 dimension(nx,nc,lmu) :: a
            integer dimension(nx),depend(nx) :: ia
            integer dimension(lmu),depend(lmu) :: nin
            real*8 dimension(ni,nc,lmu),depend(nc,lmu) :: b
        threadsafe
        end subroutine lsolns
        subroutine deviance(no,ni,x,y,g,q,nlam,a0,a,flog,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no),depend(no) :: y
            real*8 dimension(no),depend(no) :: g
            real*8 dimension(no),depend(no) :: q
            integer, optional,check(len(a0)>=nlam),depend(a0) :: nlam=len(a0)
            real*8 dimension(nlam) :: a0
            real*8 dimension(ni,nlam),depend(ni,nlam) :: a
            real*8 dimension(nlam),depend(nlam) :: flog
            integer :: jerr
        threadsafe
        end subroutine deviance
        subroutine spfishnet(parm,no,ni,x,ix,jx,y,g,w,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,intr,maxit,lmu,a0,ca,ia,nin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(len(y)>=no),depend(y) :: no=len(y)
            integer, optional,check(len(vp)>=ni),depend(vp) :: ni=len(vp)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no) :: y
            real*8 dimension(no),depend(no) :: g
            real*8 dimension(no),depend(no) :: w
            integer dimension(*) :: jd
            real*8 dimension(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer :: isd
            integer :: intr
            integer :: maxit
            integer :: lmu
            real*8 dimension(nlam),depend(nlam) :: a0
            real*8 dimension(nx,nlam),depend(nlam) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: nin
            real*8 :: dev0
            real*8 dimension(nlam),depend(nlam) :: dev
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine spfishnet
        subroutine spfishnet1(parm,no,ni,x,ix,jx,y,g,q,ju,vp,cl,ne,nx,nlam,flmin,ulam,shri,isd,intr,maxit,xb,xs,lmu,a0,ca,m,kin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(len(y)>=no),depend(y) :: no=len(y)
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no) :: y
            real*8 dimension(no),depend(no) :: g
            real*8 dimension(no),depend(no) :: q
            integer dimension(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: shri
            integer :: isd
            integer :: intr
            integer :: maxit
            real*8 dimension(ni),depend(ni) :: xb
            real*8 dimension(ni),depend(ni) :: xs
            integer :: lmu
            real*8 dimension(nlam),depend(nlam) :: a0
            real*8 dimension(nx,nlam),depend(nlam) :: ca
            integer dimension(nx),depend(nx) :: m
            integer dimension(nlam),depend(nlam) :: kin
            real*8 :: dev0
            real*8 dimension(nlam),depend(nlam) :: dev
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine spfishnet1
        subroutine spdeviance(no,ni,x,ix,jx,y,g,q,nlam,a0,a,flog,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(y)>=no),depend(y) :: no=len(y)
            integer, optional,check(shape(a,0)==ni),depend(a) :: ni=shape(a,0)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no) :: y
            real*8 dimension(no),depend(no) :: g
            real*8 dimension(no),depend(no) :: q
            integer, optional,check(len(a0)>=nlam),depend(a0) :: nlam=len(a0)
            real*8 dimension(nlam) :: a0
            real*8 dimension(ni,nlam),depend(nlam) :: a
            real*8 dimension(nlam),depend(nlam) :: flog
            integer :: jerr
        threadsafe
        end subroutine spdeviance
        subroutine cspdeviance(no,x,ix,jx,y,g,q,nx,nlam,a0,ca,ia,nin,flog,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(y)>=no),depend(y) :: no=len(y)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no) :: y
            real*8 dimension(no),depend(no) :: g
            real*8 dimension(no),depend(no) :: q
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(a0)>=nlam),depend(a0) :: nlam=len(a0)
            real*8 dimension(nlam) :: a0
            real*8 dimension(nx,nlam),depend(nlam) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: nin
            real*8 dimension(nlam),depend(nlam) :: flog
            integer :: jerr
        threadsafe
        end subroutine cspdeviance
        subroutine multelnet(parm,no,ni,nr,x,y,w,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,jsd,intr,maxit,lmu,a0,ca,ia,nin,rsq,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            integer, optional,check(shape(y,1)==nr),depend(y) :: nr=shape(y,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no,nr),depend(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer dimension(*) :: jd
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer optional,depend(x) :: ne=min(shape(x,1), nx)
            integer :: nx
            integer, optional,check((flmin < 1.0 || len(ulam)>=nlam)),depend(flmin,ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer optional :: isd=1 ! Standardize predictors by default
            integer optional :: jsd=1 ! Standardize responses by default
            integer optional :: intr=1 ! Include intercept by default
            integer optional :: maxit=100000 ! Maximum iterations

            ! Outputs
            integer intent(out) :: lmu
            real*8 intent(out),dimension(nr,nlam),depend(nr,nlam) :: a0
            real*8 intent(out),dimension(nx,nr,nlam),depend(nr,nlam) :: ca
            integer intent(out),dimension(nx),depend(nx) :: ia
            integer intent(out),dimension(nlam),depend(nlam) :: nin
            real*8 intent(out),dimension(nlam),depend(nlam) :: rsq
            real*8 intent(out),dimension(nlam),depend(nlam) :: alm
            integer intent(out) :: nlp
            integer intent(out) :: jerr
        threadsafe
        end subroutine multelnet
        subroutine multelnetn(parm,no,ni,nr,x,y,w,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,jsd,intr,maxit,lmu,a0,ca,ia,nin,rsq,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            integer, optional,check(shape(y,1)==nr),depend(y) :: nr=shape(y,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no,nr),depend(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer dimension(*) :: jd
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer :: isd
            integer :: jsd
            integer :: intr
            integer :: maxit
            integer :: lmu
            real*8 dimension(nr,nlam),depend(nr,nlam) :: a0
            real*8 dimension(nx,nr,nlam),depend(nr,nlam) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: nin
            real*8 dimension(nlam),depend(nlam) :: rsq
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine multelnetn
        subroutine multstandard1(no,ni,nr,x,y,w,isd,jsd,intr,ju,xm,xs,ym,ys,xv,ys0,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            integer, optional,check(shape(y,1)==nr),depend(y) :: nr=shape(y,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no,nr),depend(no) :: y
            real*8 dimension(no),depend(no) :: w
            integer :: isd
            integer :: jsd
            integer :: intr
            integer dimension(ni),depend(ni) :: ju
            real*8 dimension(ni),depend(ni) :: xm
            real*8 dimension(ni),depend(ni) :: xs
            real*8 dimension(nr),depend(nr) :: ym
            real*8 dimension(nr),depend(nr) :: ys
            real*8 dimension(ni),depend(ni) :: xv
            real*8 :: ys0
            integer :: jerr
        threadsafe
        end subroutine multstandard1
        subroutine multelnet2(beta,ni,nr,ju,vp,cl,y,no,ne,nx,x,nlam,flmin,ulam,thri,maxit,xv,ys0,lmu,ao,ia,kin,rsqo,almo,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: beta
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            integer, optional,check(shape(cl,1)==nr),depend(cl) :: nr=shape(cl,1)
            integer dimension(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,nr,ni),depend(ni) :: cl
            real*8 dimension(no,nr),depend(nr) :: y
            integer, optional,check(shape(y,0)==no),depend(y) :: no=shape(y,0)
            integer :: ne
            integer, optional,check(shape(ao,0)==nx),depend(ao) :: nx=shape(ao,0)
            real*8 dimension(no,ni),depend(no,ni) :: x
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thri
            integer :: maxit
            real*8 dimension(ni),depend(ni) :: xv
            real*8 :: ys0
            integer :: lmu
            real*8 dimension(nx,nr,nlam),depend(nr,nlam) :: ao
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: kin
            real*8 dimension(nlam),depend(nlam) :: rsqo
            real*8 dimension(nlam),depend(nlam) :: almo
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine multelnet2
        subroutine chkbnds(nr,gk,gkn,xv,cl,al1,al2,a,isc,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(gk)>=nr),depend(gk) :: nr=len(gk)
            real*8 dimension(nr) :: gk
            real*8 :: gkn
            real*8 :: xv
            real*8 dimension(2,nr),depend(nr) :: cl
            real*8 :: al1
            real*8 :: al2
            real*8 dimension(nr),depend(nr) :: a
            integer dimension(nr),depend(nr) :: isc
            integer :: jerr
        threadsafe
        end subroutine chkbnds
        subroutine chkbnds1(nr,gk,gkn,xv,cl1,cl2,al1,al2,a,isc,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(len(gk)>=nr),depend(gk) :: nr=len(gk)
            real*8 dimension(nr) :: gk
            real*8 :: gkn
            real*8 :: xv
            real*8 :: cl1
            real*8 :: cl2
            real*8 :: al1
            real*8 :: al2
            real*8 dimension(nr),depend(nr) :: a
            integer dimension(nr),depend(nr) :: isc
            integer :: jerr
        threadsafe
        end subroutine chkbnds1
        function bnorm(b0,al1p,al2p,g,usq,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: b0
            real*8 :: al1p
            real*8 :: al2p
            real*8 :: g
            real*8 :: usq
            integer :: jerr
            real*8 :: bnorm
        end function bnorm
        subroutine chg_bnorm(arg,irg) ! in :glmnet5:glmnet5.f
            real*8 :: arg
            integer :: irg
        threadsafe
        end subroutine chg_bnorm
        subroutine get_bnorm(arg,irg) ! in :glmnet5:glmnet5.f
            real*8 :: arg
            integer :: irg
        threadsafe
        end subroutine get_bnorm
        subroutine multsolns(ni,nx,nr,lmu,a,ia,nin,b) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(b,0)==ni),depend(b) :: ni=shape(b,0)
            integer, optional,check(shape(a,0)==nx),depend(a) :: nx=shape(a,0)
            integer, optional,check(shape(a,1)==nr),depend(a) :: nr=shape(a,1)
            integer, optional,check(shape(a,2)==lmu),depend(a) :: lmu=shape(a,2)
            real*8 dimension(nx,nr,lmu) :: a
            integer dimension(nx),depend(nx) :: ia
            integer dimension(lmu),depend(lmu) :: nin
            real*8 dimension(ni,nr,lmu),depend(nr,lmu) :: b
        threadsafe
        end subroutine multsolns
        subroutine multuncomp(ni,nr,nx,ca,ia,nin,a) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(a,0)==ni),depend(a) :: ni=shape(a,0)
            integer, optional,check(shape(ca,1)==nr),depend(ca) :: nr=shape(ca,1)
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            real*8 dimension(nx,nr) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer :: nin
            real*8 dimension(ni,nr),depend(nr) :: a
        threadsafe
        end subroutine multuncomp
        subroutine multmodval(nx,nr,a0,ca,ia,nin,n,x,f) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(a0)>=nr),depend(a0) :: nr=len(a0)
            real*8 dimension(nr) :: a0
            real*8 dimension(nx,nr),depend(nr) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer :: nin
            integer, optional,check(shape(x,0)==n),depend(x) :: n=shape(x,0)
            real*8 dimension(n,*) :: x
            real*8 dimension(nr,n),depend(nr,n) :: f
        threadsafe
        end subroutine multmodval
        subroutine multspelnet(parm,no,ni,nr,x,ix,jx,y,w,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,jsd,intr,maxit,lmu,a0,ca,ia,nin,rsq,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            integer, optional,check(shape(y,1)==nr),depend(y) :: nr=shape(y,1)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no,nr) :: y
            real*8 dimension(no),depend(no) :: w
            integer dimension(*) :: jd
            real*8 dimension(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer optional :: isd=1 ! Standardize precictors by default
            integer optional :: jsd=1 ! Standardize responses by default
            integer optional :: intr=1 ! Include intercept by default
            integer optional :: maxit=100000 ! Maximum iterations

            !Outputs
            integer intent(out) :: lmu
            real*8 intent(out),dimension(nr,nlam),depend(nr,nlam) :: a0
            real*8 intent(out),dimension(nx,nr,nlam),depend(nr,nlam) :: ca
            integer intent(out),dimension(nx),depend(nx) :: ia
            integer intent(out),dimension(nlam),depend(nlam) :: nin
            real*8 intent(out),dimension(nlam),depend(nlam) :: rsq
            real*8 intent(out),dimension(nlam),depend(nlam) :: alm
            integer intent(out):: nlp
            integer intent(out):: jerr
        threadsafe
        end subroutine multspelnet
        subroutine multspelnetn(parm,no,ni,nr,x,ix,jx,y,w,jd,vp,cl,ne,nx,nlam,flmin,ulam,thr,isd,jsd,intr,maxit,lmu,a0,ca,ia,nin,rsq,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(y,0)==no),depend(y) :: no=shape(y,0)
            integer, optional,check(len(vp)>=ni),depend(vp) :: ni=len(vp)
            integer, optional,check(shape(y,1)==nr),depend(y) :: nr=shape(y,1)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no,nr) :: y
            real*8 dimension(no),depend(no) :: w
            integer dimension(*) :: jd
            real*8 dimension(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(ca,0)==nx),depend(ca) :: nx=shape(ca,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thr
            integer :: isd
            integer :: jsd
            integer :: intr
            integer :: maxit
            integer :: lmu
            real*8 dimension(nr,nlam),depend(nr,nlam) :: a0
            real*8 dimension(nx,nr,nlam),depend(nr,nlam) :: ca
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: nin
            real*8 dimension(nlam),depend(nlam) :: rsq
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine multspelnetn
        subroutine multspstandard1(no,ni,nr,x,ix,jx,y,w,ju,isd,jsd,intr,xm,xs,ym,ys,xv,ys0,jerr) ! in :glmnet5:glmnet5.f
            integer, optional,check(shape(y,0)==no),depend(y) :: no=shape(y,0)
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            integer, optional,check(shape(y,1)==nr),depend(y) :: nr=shape(y,1)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no,nr) :: y
            real*8 dimension(no),depend(no) :: w
            integer dimension(ni) :: ju
            integer :: isd
            integer :: jsd
            integer :: intr
            real*8 dimension(ni),depend(ni) :: xm
            real*8 dimension(ni),depend(ni) :: xs
            real*8 dimension(nr),depend(nr) :: ym
            real*8 dimension(nr),depend(nr) :: ys
            real*8 dimension(ni),depend(ni) :: xv
            real*8 :: ys0
            integer :: jerr
        threadsafe
        end subroutine multspstandard1
        subroutine multspelnet2(beta,ni,nr,y,w,no,ne,nx,x,ix,jx,ju,vp,cl,nlam,flmin,ulam,thri,maxit,xm,xs,xv,ys0,lmu,ao,ia,kin,rsqo,almo,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: beta
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            integer, optional,check(shape(y,1)==nr),depend(y) :: nr=shape(y,1)
            real*8 dimension(no,nr) :: y
            real*8 dimension(no),depend(no) :: w
            integer, optional,check(shape(y,0)==no),depend(y) :: no=shape(y,0)
            integer :: ne
            integer, optional,check(shape(ao,0)==nx),depend(ao) :: nx=shape(ao,0)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            integer dimension(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,nr,ni),depend(nr,ni) :: cl
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: thri
            integer :: maxit
            real*8 dimension(ni),depend(ni) :: xm
            real*8 dimension(ni),depend(ni) :: xs
            real*8 dimension(ni),depend(ni) :: xv
            real*8 :: ys0
            integer :: lmu
            real*8 dimension(nx,nr,nlam),depend(nr,nlam) :: ao
            integer dimension(nx),depend(nx) :: ia
            integer dimension(nlam),depend(nlam) :: kin
            real*8 dimension(nlam),depend(nlam) :: rsqo
            real*8 dimension(nlam),depend(nlam) :: almo
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine multspelnet2
        subroutine multlognetn(parm,no,ni,nc,x,y,g,w,ju,vp,cl,ne,nx,nlam,flmin,ulam,shri,intr,maxit,xv,lmu,a0,a,m,kin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(x,0)==no),depend(x) :: no=shape(x,0)
            integer, optional,check(shape(x,1)==ni),depend(x) :: ni=shape(x,1)
            integer, optional,check(shape(y,1)==nc),depend(y) :: nc=shape(y,1)
            real*8 dimension(no,ni) :: x
            real*8 dimension(no,nc),depend(no) :: y
            real*8 dimension(no,nc),depend(no,nc) :: g
            real*8 dimension(no),depend(no) :: w
            integer dimension(ni),depend(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(a,0)==nx),depend(a) :: nx=shape(a,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: shri
            integer :: intr
            integer :: maxit
            real*8 dimension(ni),depend(ni) :: xv
            integer :: lmu
            real*8 dimension(nc,nlam),depend(nc,nlam) :: a0
            real*8 dimension(nx,nc,nlam),depend(nc,nlam) :: a
            integer dimension(nx),depend(nx) :: m
            integer dimension(nlam),depend(nlam) :: kin
            real*8 :: dev0
            real*8 dimension(nlam),depend(nlam) :: dev
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine multlognetn
        subroutine multsprlognetn(parm,no,ni,nc,x,ix,jx,y,g,w,ju,vp,cl,ne,nx,nlam,flmin,ulam,shri,intr,maxit,xv,xb,xs,lmu,a0,a,m,kin,dev0,dev,alm,nlp,jerr) ! in :glmnet5:glmnet5.f
            real*8 :: parm
            integer, optional,check(shape(y,0)==no),depend(y) :: no=shape(y,0)
            integer, optional,check(len(ju)>=ni),depend(ju) :: ni=len(ju)
            integer, optional,check(shape(y,1)==nc),depend(y) :: nc=shape(y,1)
            real*8 dimension(*) :: x
            integer dimension(*) :: ix
            integer dimension(*) :: jx
            real*8 dimension(no,nc) :: y
            real*8 dimension(no,nc),depend(no,nc) :: g
            real*8 dimension(no),depend(no) :: w
            integer dimension(ni) :: ju
            real*8 dimension(ni),depend(ni) :: vp
            real*8 dimension(2,ni),depend(ni) :: cl
            integer :: ne
            integer, optional,check(shape(a,0)==nx),depend(a) :: nx=shape(a,0)
            integer, optional,check(len(ulam)>=nlam),depend(ulam) :: nlam=len(ulam)
            real*8 :: flmin
            real*8 dimension(nlam) :: ulam
            real*8 :: shri
            integer :: intr
            integer :: maxit
            real*8 dimension(ni),depend(ni) :: xv
            real*8 dimension(ni),depend(ni) :: xb
            real*8 dimension(ni),depend(ni) :: xs
            integer :: lmu
            real*8 dimension(nc,nlam),depend(nc,nlam) :: a0
            real*8 dimension(nx,nc,nlam),depend(nc,nlam) :: a
            integer dimension(nx),depend(nx) :: m
            integer dimension(nlam),depend(nlam) :: kin
            real*8 :: dev0
            real*8 dimension(nlam),depend(nlam) :: dev
            real*8 dimension(nlam),depend(nlam) :: alm
            integer :: nlp
            integer :: jerr
        threadsafe
        end subroutine multsprlognetn
        subroutine psort7(v,a,ii,jj) ! in :glmnet5:glmnet5.f
            real*8 dimension(jj) :: v
            integer dimension(jj),depend(jj) :: a
            integer :: ii
            integer, optional,check(len(v)>=jj),depend(v) :: jj=len(v)
        threadsafe
        end subroutine psort7
    end interface
end python module glmnet5

! This file was auto-generated with f2py (version:2).
! See http://cens.ioc.ee/projects/f2py2e/
